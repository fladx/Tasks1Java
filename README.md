# Кастомный пул потоков - Отчет о реализации

## Введение
Этот проект представляет собой реализацию кастомного пула потоков для высоконагруженных серверных приложений. Основная цель - обеспечить гибкость и эффективность управления распределением задач между потоками, предоставляя возможности для настройки, которые отсутствуют в стандартном `ThreadPoolExecutor`.

## Структура проекта

Проект состоит из следующих основных компонентов:

1. **CustomExecutor** - интерфейс, определяющий основное API пула потоков
2. **CustomThreadPool** - основная реализация пула потоков
3. **Worker** - рабочий поток, обрабатывающий задачи из закрепленной очереди
4. **CustomThreadFactory** - фабрика потоков с логированием создания/завершения
5. **RejectedTaskHandler** - обработчик отклоненных задач с различными стратегиями
6. **Main** - демонстрационный класс для тестирования пула

## Особенности реализации

### Параметры настройки пула

- **corePoolSize** - минимальное (базовое) количество потоков
- **maxPoolSize** - максимальное количество потоков
- **minSpareThreads** - минимальное число свободных потоков
- **keepAliveTime и timeUnit** - время, через которое поток может завершиться при простое
- **queueSize** - ограничение на количество задач в очереди

### Распределение задач

В реализации используется алгоритм **Round Robin** для балансировки задач между потоками. Каждый поток имеет свою очередь задач, и новые задачи распределяются циклически между существующими потоками.

Преимущества подхода:
- Простая и предсказуемая балансировка нагрузки
- Равномерное распределение задач
- Снижение конкуренции потоков за доступ к общей очереди

Недостатки:
- Не учитывает фактическую загруженность потоков
- Не оптимален для задач с сильно различающимся временем выполнения

### Обработка отказов

Реализовано три политики обработки отказов:

1. **AbortPolicy** - отклоняет задачу с выбросом исключения
2. **CallerRunsPolicy** - выполняет задачу в потоке, который пытается её отправить
3. **DiscardPolicy** - отбрасывает задачу без уведомления

В тестовом примере используется `CallerRunsPolicy`, что обеспечивает регулирование нагрузки (throttling): если пул перегружен, задача будет выполняться в потоке отправителя, естественным образом замедляя отправку новых задач.

### Механизм резервных потоков

Уникальной особенностью данного пула является параметр `minSpareThreads`. При снижении количества свободных потоков ниже этого значения, пул автоматически создает дополнительные потоки, даже при невысокой нагрузке. Это позволяет:
- Быстрее реагировать на внезапные всплески нагрузки
- Обеспечить гарантированный запас производительности
- Снизить время отклика для новых задач

## Анализ производительности

### Сравнение со стандартным ThreadPoolExecutor

#### Преимущества кастомного пула:
1. **Изолированные очереди для каждого потока** - снижают конкуренцию за блокировки при добавлении/извлечении задач
2. **Контроль резервных потоков** - обеспечивает более быструю реакцию на пиковые нагрузки
3. **Гибкие возможности логирования** - позволяют лучше отслеживать работу пула

#### Недостатки:
1. **Увеличенное потребление памяти** - из-за использования множества очередей
2. **Потенциальная неравномерность нагрузки** - при использовании Round Robin
3. **Возможная неэффективность** - при большом количестве потоков с пустыми очередями

### Оптимальные значения параметров

В результате тестирования были выявлены следующие рекомендации по настройке пула:

1. **corePoolSize:** Рекомендуется устанавливать равным количеству доступных ядер процессора
2. **maxPoolSize:** Оптимально устанавливать в 2-4 раза больше corePoolSize
3. **queueSize:** Влияет на использование памяти и скорость отказа в обслуживании. Оптимально 100-500 для большинства задач
4. **minSpareThreads:** 10-20% от maxPoolSize для обеспечения быстрой реакции на нагрузку
5. **keepAliveTime:** 30-60 секунд для балансировки между отзывчивостью и эффективностью использования ресурсов

## Принцип действия механизма распределения задач

Наш пул использует модифицированную схему Round Robin с учетом минимального количества резервных потоков:

1. При добавлении задачи пул проверяет текущее количество свободных потоков
2. Если их число меньше `minSpareThreads`, создаются дополнительные потоки
3. Затем выбирается индекс потока с помощью атомарного счетчика
4. Задача добавляется в очередь выбранного потока
5. Если все очереди заполнены и создано максимальное число потоков, применяется политика отказа

## Заключение

Разработанный пул потоков предлагает улучшенную гибкость и контроль над выполнением задач по сравнению со стандартным ThreadPoolExecutor. Особенно эффективен в сценариях с неравномерной нагрузкой и необходимостью быстрой реакции на пики активности.

Для дальнейшего улучшения можно:
1. Реализовать алгоритм Least Loaded для более эффективной балансировки
2. Добавить метрики и мониторинг для каждого потока
3. Внедрить адаптивное изменение параметров на основе текущей нагрузки 